{
  "hash": "65ba6caff877f2b7d76133ee9f1e89f9",
  "result": {
    "markdown": "---\ntitle: Learn RL Fundamentals in Five Minutes (Level 2)\nauthor: Jay Lowe\ndate: '2023-01-14'\ncategories:\n  - RL\n  - Beginner\nimage: rl_agent_level2.jpeg\nformat:\n  html:\n    code-fold: false\n    smooth-scroll: true\n---\n\n##### Article Summary\n\n> Learn how a reinforcement learning (RF) algorithm uses `policy` and `value functions` to balance short vs long term `rewards`.\n\nNew to the blog? Start at [Learn RL Fundamentals in Five Minutes Level 1](../Learn_RL_Fudamentals_in_five_minutes_level_one/index.qmd).\n\n# Additional components of an RL algorithm\n\nNow that we know the basics, we must capture some additional nuances required to effectively communicate to an algorithm what it must accomplish.\n\n## How an RL agent knows which actions to take\n\nAn `environment` can be used in many different ways depending on the `goal` an `agent` has at the time (imagine all the ways you can use your kitchent).\n\nThe `policy` determines which `actions` lead to the best outcome by mapping all `actions` possible, given the state of the `environment`, to a known `reward` value.\n\nFor example, an agent such as Rae operating in her bedroom will have seperate `policies` when playing vs going to sleep. Her playtime `policy` will put rewards on actions related to her toys while her sleep `policy` will place a reward on actions that calm her down.\n\n## Actions have results\n\nAfter taking an `action` in its `environment`, the `agent` will measure how much progress it made towards its `goal`.\n\nThe amount of progess made takes the form of a singular number known as the `reward signal`. RL agents exist to find the path to maximum `reward`.\n\nRL agents will sometimes use the resulting `reward` to alter the `policy` mappings.\n\nIf Rae finds that playing with a toy in a particular way was especially fun when using her playtime `policy`, she may value that `action` more next she plays.\n\n## Rewards have both an immedate and long term payoff\n\nHow do RL agents handle differed rewards? If for example I offered you $1,000 today or $10,000 dollars tomorrow--which one leads to the most long term `reward`?\n\nThe `value function` bakes in discounted future rewards in conjunction with the immedate rewards to better represent which actions lead to the best long term outcome.\n\nRL agents will always attempt to find the optimal `policy` that leads to optimal `rewards`.\n\nComing back to Rae's playtime `policy`, taking the time to slowly build up a large tower of blocks might not be that fun until the last piece gets put into place--upon which a massive `reward` spike hits and she has the most fun possible.\n\nDimming the lights and reading stories during her sleeping `policy` might not immedately lead to sleep, as opposed to forcing her into bed, but they put her into a tired state that greatly increases the chances of the sleep `action` occuring.\n\n**An effective `value function` represents effective estimation of value--the single most important component to an RL agent--as this leads to accurate mappings of `actions` to `reward`.**\n\n## Planning for future actions\n\nSometimes an RL agent will have access to an `environment` `model` that estimates the results of an `action`.\n\nA `model` may not always be available but can be particularly useful for games, or simple physics `environments`, in which clear causation exists.\n\nWhen I'm teaching Rae about physical phenomona such as the water cycle, I will often employ a `model` that includes a temperature scale and the states of water for experimentation.\n\n## The difference between reinforcment learning, supervised learning, and unsupervised learning\n\nSupervised learning typically means we supply the algorithm with some form of training dataset that we have vetted as correct. For example, a computer vision model will be trained on pictures with human generated lables specifying what each object in the picture represents.\n\nUnsupervised learning removes the human verified data and substitues it with a method to find hidden correlations and trends to create machine generated training data.\n\nUnlike these traditional machine learning (ML) algorithms, RL algorithms do not utilize a training datset. Instead they attempt to maximize reward through repeated exploration and exploitation.\n\n### RL can be combined with other ML techniques\n\nRL algorithms can utilize techniques found in un/supervised learning, and can also benefit from the introduction of sub-problems, but fundamentally does not require them.\n\nI think of RL algorithms as a way to imitate the learning processes used by humans, and other animals, and often mimics known nuerological phenomoman observed in the biology fields.\n\n\n#### Deep reinforcment learning explained\n\nUse a deep neural network for your `policy` and you have deep RL!\n\n\n## Conclusion\n\nEstablishing the proper `policy` and `value functions` provides context for `reward`. \n\n`Rewards` can get complex, but finding the right balance of short and long term `reward` structures leads to the highest performing agents.\n\nTest yourself with the following questions:\n- \"When should algorithms have a premium on short term rewards vs long term rewards\"\n- \"What `enviroment` factors should an engineer consider when creating dynamic value functions\"\n\nTweet your answer to me at [@ogjaylowe](https://twitter.com/ogjaylowe) so we can have a chat about it! Would love to discuss.\n\n## What to read next\n\nReady to start coding? \n\nUp next read about [creating a simple bandit](../Creating_Simple_N-Arm_Bandits_for_RL_Agents/index.qmd).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}